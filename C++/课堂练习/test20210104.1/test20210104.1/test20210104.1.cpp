// test20210104.1.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>#include<iomanip>#include<string>#include<stdlib.h>#include<deque>using namespace std;int m = 0;template <class T>struct BiNode   //二叉树的结点结构{	T data;	BiNode<T> *lchild, *rchild;};template <class T>class BiTree{ //二叉树类public:	BiTree();       //构造函数，键盘输入扩展二叉树的前序序列构造二叉树	BiTree(char *s); //构造函数，由扩展二叉树的前序遍历序列s构造二叉树	~BiTree(void);         //析构函数，释放二叉链表中各结点的存储空间	BiNode<T>* Getroot();  //获得指向根结点的指针	void PreOrder(BiNode<T> *root);     //前序遍历二叉树递归	void InOrder(BiNode<T> *root);      //中序遍历二叉树递归	void PostOrder(BiNode<T> *root);    //后序遍历二叉树递归private:	BiNode<T> *root;         //指向根结点的头指针	BiNode<T> *Creat();     //无参构造函数调用	BiNode<T> *Creat(char *s);     //有参构造函数调用	void Release(BiNode<T> *root);   //析构函数调用};/**前置条件：二叉树不存在*输    入：无*功    能：构造一棵二叉树*输    出：无*后置条件：产生一棵二叉树*/template<class T>BiTree<T>::BiTree(char *s){	m = 0;	root = Creat(s);}template<class T>BiTree<T>::BiTree(){	root = Creat();}/**前置条件：二叉树已存在*输    入：无*功    能：释放二叉链表中各结点的存储空间*输    出：无*后置条件：二叉树不存在*/template<class T>BiTree<T>::~BiTree(void){	Release(root);}/**前置条件：二叉树已存在*输    入：无*功    能：获取指向二叉树根结点的指针*输    出：指向二叉树根结点的指针*后置条件：二叉树不变*/template<class T>BiNode<T>* BiTree<T>::Getroot(){	return root;}/**前置条件：二叉树已存在*输    入：无*功    能：前序遍历二叉树*输    出：二叉树中结点的一个线性排列*后置条件：二叉树不变*/template<class T>void BiTree<T>::PreOrder(BiNode<T> *root){	if (root == NULL)  return;	else {		cout << root->data << " ";		PreOrder(root->lchild);		PreOrder(root->rchild);	}}/**前置条件：二叉树已存在*输    入：无*功    能：中序遍历二叉树*输    出：二叉树中结点的一个线性排列*后置条件：二叉树不变*/template <class T>void BiTree<T>::InOrder(BiNode<T> *root){	if (root == NULL)  return;      //递归调用的结束条件	else {		InOrder(root->lchild);    //中序递归遍历root的左子树		cout << root->data << " ";    //访问根结点的数据域		InOrder(root->rchild);    //中序递归遍历root的右子树	}}/**前置条件：二叉树已存在*输    入：无*功    能：后序遍历二叉树*输    出：二叉树中结点的一个线性排列*后置条件：二叉树不变*/template <class T>void BiTree<T>::PostOrder(BiNode<T> *root){	if (root == NULL)   return;       //递归调用的结束条件	else {		PostOrder(root->lchild);    //后序递归遍历root的左子树		PostOrder(root->rchild);    //后序递归遍历root的右子树		cout << root->data << " ";      //访问根结点的数据域	}}/**前置条件：空二叉树*输    入：数据ch;*功    能：初始化一棵二叉树,构造函数调用*输    出：无*后置条件：产生一棵二叉树*///int m=0;template <class T>BiNode<T>* BiTree<T>::Creat(char *s){	BiNode<T>* root;	char ch = s[m++];	//cout<<"请输入创建一棵二叉树的结点数据"<<endl;	//cin>>ch;	if (ch == '#') root = NULL;	else {		root = new BiNode<T>;       //生成一个结点		root->data = ch;		root->lchild = Creat(s);    //递归建立左子树		root->rchild = Creat(s);    //递归建立右子树	}	return root;}template <class T>BiNode<T>* BiTree <T>::Creat(){	BiNode<T>* root;	char ch;	cout << "Input a char: ";	cin >> ch;	if (ch == '#')     root = NULL;	else {		root = new BiNode<T>;		root->data = ch;		root->lchild = Creat();		root->rchild = Creat();	}	return root;}/**前置条件：二叉树已经存在*输    入：无*功    能：释放二叉树的存储空间，析构函数调用*输    出：无*后置条件：二叉树不存在*/template<class T>void BiTree<T>::Release(BiNode<T>* root){	if (root != NULL)	{		Release(root->lchild);   //释放左子树		Release(root->rchild);   //释放右子树		delete root;	}}template <class T>void Count(BiNode<T> *root, int &n)  //n为全局量并已初始化为0{//求二叉树结点个数	if (root)	{		Count(root->lchild, n);		n++;		Count(root->rchild, n);	}}template <class T>int CountNodes(BiNode<T> *root){//求二叉树结点个数	int n = 0;	Count(root, n);	return n;}template <class T>void Count1(BiNode<T>* root, int& m)  //n为全局量并已初始化为0{//求二叉树叶子结点个数	if (root)	{		if (!root->lchild && !root->rchild)			m++;		Count1(root->lchild, m);		Count1(root->rchild, m);	}}template <class T>int Count1Nodes(BiNode<T>* root){//求二叉树叶子结点个数	int m = 0;	Count1(root, m);	return m;}template <class T>int  Depth(BiNode<T> *root){//求二叉树的高度	if (root == NULL) return 0;	else	{		int hl = Depth(root->lchild);		int hr = Depth(root->rchild);		return hl>hr ? hl + 1 : hr + 1;	}}template <class T>int CountDC(BiNode<T> *root)//计算二叉树中有所有叶子结点的和。{	if (root == NULL) return 0;	else {		if (root->lchild == NULL&& root->rchild == NULL)			return (int)(root->data);		else			return (CountDC(root->lchild) + CountDC(root->rchild));	}}//binary node with parent nodetemplate<typename T>class node{public:	node(const T& v, node<T>* L = NULL, node<T>* R = NULL, node<T>* P = NULL) :left(L), right(R), par(P)	{		value = v;	}public:	T value;	node<T>* left, *right, *par;};// binary treetemplate<typename T>class BTree{public:	BTree(node<T>* R = NULL) :root(R)	{ }	~BTree()	{		if (root)			delall();	}	node<T>* findby(const T& v);    // 层次遍历,返回找到第一个结点值为v的结点指针	void Insert(const T& v);        // 层次遍历二叉树,将值插在遇到的第一个叶子或者子树不全的结点上	node<T>* findleave(node<T>* cur); // 层次遍历二叉树,返回cur下遇到的第一个叶子结点	void delall();	void display(node<T>* r);        // 先序遍历,打印二叉树各结点的值public:	node<T>* root;};template<typename T>node<T>* BTree<T>::findby(const T& v){	deque< node<T>* > Q;	bool isfind; // find v ==> isfind = true; not find ==> isfind = false	node<T>* tmp;	if (root)		Q.push_back(root);	else	{		return NULL;	}	isfind = false;	tmp = NULL;	while (!Q.empty() && !isfind)	{		tmp = Q.front();		Q.pop_front();		if (tmp->value == v)			isfind = true;		else		{			if (tmp->left)				Q.push_back(tmp->left);			if (tmp->right)				Q.push_back(tmp->right);		}	}	if (!isfind)		tmp = NULL;	return tmp;}template<typename T>void BTree<T>::Insert(const T& v){	deque< node<T>* > Q;	node<T>* cur;	if (root)		Q.push_back(root);	else	{		root = new node<T>(v, NULL, NULL, NULL);		return;	}	while (!Q.empty()) // 原来是这里出错了.第一次是写了Q.empty(),应该是!Q.empty()	{		cur = Q.front();		Q.pop_front();		if (cur->left)			Q.push_back(cur->left);		else		{			cur->left = new node<T>(v, NULL, NULL, cur);			return;		}		if (cur->right)			Q.push_back(cur->right);		else		{			cur->right = new node<T>(v, NULL, NULL, cur);			return;		}	}}// 层次遍历二叉树,返回遇到的第一个叶子.二叉树的叶子特征:左右子树为NULLtemplate<typename T>node<T>* BTree<T>::findleave(node<T>* cur){	deque< node<T>* > Q;    // 用于层次遍历的双端队列	node<T>* tmp;            // 返回的叶子指针	bool isfind;            // 用来跳出while循环的flag	if (!cur)                // 假如cur为空,则返回NULL		return NULL;	else		Q.push_back(cur);    // 推进Q中	isfind = false;	while (!Q.empty() && !isfind)    // 当队列为空或者找到叶子时终止循环	{		tmp = Q.front();		Q.pop_front();		if (!tmp->left && !tmp->right)			isfind = true;		else if (tmp->left)			Q.push_back(tmp->left);		else			Q.push_back(tmp->right);	}	// 处理该叶子的父结点	if (tmp->par)		(tmp == tmp->par->left) ? (tmp->par->left = NULL) : (tmp->par->right = NULL);	return tmp;}// 通过层次遍历删除二叉树所有结点template<typename T>void BTree<T>::delall(){	deque< node<T>* > Q;	// 假如root为空,则直接返回,不为空,则推进Q中	if (root)		Q.push_back(root);	else		return;	while (!Q.empty())	{		root = Q.front();		Q.pop_front();		if (root->left)			Q.push_back(root->left);		if (root->right)			Q.push_back(root->right);		delete root;		root = NULL;	}}// 通过前序遍历打印二叉树各结点的值template<typename T>void BTree<T>::display(node<T>* r){	if (r)	{		cout << r->value << ' ';		display(r->left);		display(r->right);	}}int main(){	BiNode<int>* root;	BiTree<int> bt; //创建一棵二叉树	BTree<int> BT;	root = bt.Getroot();  //获取指向根结点的指针	cout << "------前序遍历------ " << endl;	bt.PreOrder(root);	cout << endl;	cout << "------中序遍历------ " << endl;	bt.InOrder(root);	cout << endl;	cout << "------后序遍历------ " << endl;	bt.PostOrder(root);	cout << endl;	cout << "Number of nodes=" << CountNodes(root) << endl;	cout << "Leaf-nodes are " << Count1Nodes(root) << endl;	cout << "Depth=" << Depth(root) << endl;	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };	for (int it = 0; it < sizeof(a) / sizeof(a[0]); it++)		BT.Insert(a[it]); // 第一次测试,Insert不成功,Insert 已修正	BT.display(BT.root);	cout << endl;	BT.findby(4);	BT.Insert(5);	BT.display(BT.root);	cout << endl;	return 0;}